// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package queries

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimOutboxBatch = `-- name: ClaimOutboxBatch :many
WITH claimed AS (
    SELECT id, created_at
    FROM outboxes
    WHERE published_at IS NULL
      AND attempts < $1::int4
    ORDER BY seq
    LIMIT $2::int4
    FOR UPDATE SKIP LOCKED
)
UPDATE outboxes o
SET attempts = o.attempts + 1
FROM claimed c
WHERE o.id = c.id AND o.created_at = c.created_at
RETURNING o.id, o.created_at, o.topic, o.metadata, o.payload, o.published_at, o.attempts, o.last_error
`

type ClaimOutboxBatchParams struct {
	MaxAttempts int32 `db:"max_attempts" json:"max_attempts"`
	BatchSize   int32 `db:"batch_size" json:"batch_size"`
}

type ClaimOutboxBatchRow struct {
	ID          pgtype.UUID `db:"id" json:"id"`
	CreatedAt   time.Time   `db:"created_at" json:"created_at"`
	Topic       string      `db:"topic" json:"topic"`
	Metadata    []byte      `db:"metadata" json:"metadata"`
	Payload     []byte      `db:"payload" json:"payload"`
	PublishedAt *time.Time  `db:"published_at" json:"published_at"`
	Attempts    int32       `db:"attempts" json:"attempts"`
	LastError   pgtype.Text `db:"last_error" json:"last_error"`
}

// Claims a batch of unpublished events using FOR UPDATE SKIP LOCKED
// This provides automatic distributed coordination without explicit locks
// Orders by seq for strict FIFO ordering
func (q *Queries) ClaimOutboxBatch(ctx context.Context, arg ClaimOutboxBatchParams) ([]ClaimOutboxBatchRow, error) {
	rows, err := q.db.Query(ctx, claimOutboxBatch, arg.MaxAttempts, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ClaimOutboxBatchRow{}
	for rows.Next() {
		var i ClaimOutboxBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Topic,
			&i.Metadata,
			&i.Payload,
			&i.PublishedAt,
			&i.Attempts,
			&i.LastError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishingMetrics = `-- name: GetPublishingMetrics :one
SELECT 
    COUNT(*) FILTER (WHERE published_at IS NULL)::int8 as pending_count,
    COUNT(*) FILTER (WHERE published_at IS NULL AND attempts > 0)::int8 as retry_count,
    COUNT(*) FILTER (WHERE attempts >= $1::int4)::int8 as failed_count,
    MIN(created_at) FILTER (WHERE published_at IS NULL) as oldest_unpublished,
    MAX(created_at) FILTER (WHERE published_at IS NOT NULL) as latest_published,
    COUNT(*) FILTER (WHERE published_at IS NOT NULL AND published_at > NOW() - INTERVAL '1 minute')::int8 as published_last_minute
FROM outboxes
WHERE created_at > NOW() - INTERVAL '1 hour'
`

type GetPublishingMetricsRow struct {
	PendingCount        int64       `db:"pending_count" json:"pending_count"`
	RetryCount          int64       `db:"retry_count" json:"retry_count"`
	FailedCount         int64       `db:"failed_count" json:"failed_count"`
	OldestUnpublished   interface{} `db:"oldest_unpublished" json:"oldest_unpublished"`
	LatestPublished     interface{} `db:"latest_published" json:"latest_published"`
	PublishedLastMinute int64       `db:"published_last_minute" json:"published_last_minute"`
}

// Get metrics for monitoring
func (q *Queries) GetPublishingMetrics(ctx context.Context, maxAttempts int32) (GetPublishingMetricsRow, error) {
	row := q.db.QueryRow(ctx, getPublishingMetrics, maxAttempts)
	var i GetPublishingMetricsRow
	err := row.Scan(
		&i.PendingCount,
		&i.RetryCount,
		&i.FailedCount,
		&i.OldestUnpublished,
		&i.LatestPublished,
		&i.PublishedLastMinute,
	)
	return i, err
}

const getStuckEvents = `-- name: GetStuckEvents :many
SELECT id, created_at, topic, attempts, last_error
FROM outboxes
WHERE published_at IS NULL
  AND attempts > 0
  AND created_at < NOW() - INTERVAL '5 minutes'
ORDER BY seq
LIMIT $1::int4
`

type GetStuckEventsRow struct {
	ID        pgtype.UUID `db:"id" json:"id"`
	CreatedAt time.Time   `db:"created_at" json:"created_at"`
	Topic     string      `db:"topic" json:"topic"`
	Attempts  int32       `db:"attempts" json:"attempts"`
	LastError pgtype.Text `db:"last_error" json:"last_error"`
}

// Find events that have been attempted but not published (for monitoring)
func (q *Queries) GetStuckEvents(ctx context.Context, maxLimit int32) ([]GetStuckEventsRow, error) {
	rows, err := q.db.Query(ctx, getStuckEvents, maxLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStuckEventsRow{}
	for rows.Next() {
		var i GetStuckEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Topic,
			&i.Attempts,
			&i.LastError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEventPublished = `-- name: MarkEventPublished :exec
UPDATE outboxes 
SET published_at = NOW()
WHERE id = $1::uuid 
  AND created_at = $2::timestamptz
`

type MarkEventPublishedParams struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

// Mark an event as successfully published
func (q *Queries) MarkEventPublished(ctx context.Context, arg MarkEventPublishedParams) error {
	_, err := q.db.Exec(ctx, markEventPublished, arg.ID, arg.CreatedAt)
	return err
}

const recordEventError = `-- name: RecordEventError :exec
UPDATE outboxes 
SET last_error = $1::varchar
WHERE id = $2::uuid 
  AND created_at = $3::timestamptz
`

type RecordEventErrorParams struct {
	Error     string             `db:"error" json:"error"`
	ID        pgtype.UUID        `db:"id" json:"id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

// Record an error for a failed event
func (q *Queries) RecordEventError(ctx context.Context, arg RecordEventErrorParams) error {
	_, err := q.db.Exec(ctx, recordEventError, arg.Error, arg.ID, arg.CreatedAt)
	return err
}

const resetStuckEvents = `-- name: ResetStuckEvents :exec
UPDATE outboxes
SET attempts = 0,
    last_error = NULL
WHERE published_at IS NULL
  AND attempts >= $1::int4
  AND created_at BETWEEN $2::timestamptz AND $3::timestamptz
`

type ResetStuckEventsParams struct {
	MaxAttempts int32              `db:"max_attempts" json:"max_attempts"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime     pgtype.Timestamptz `db:"end_time" json:"end_time"`
}

// Reset stuck events for retry (admin operation)
func (q *Queries) ResetStuckEvents(ctx context.Context, arg ResetStuckEventsParams) error {
	_, err := q.db.Exec(ctx, resetStuckEvents, arg.MaxAttempts, arg.StartTime, arg.EndTime)
	return err
}
